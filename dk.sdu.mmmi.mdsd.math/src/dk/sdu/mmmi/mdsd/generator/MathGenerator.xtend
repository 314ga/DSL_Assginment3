/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.LetBinding
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.MathNumber
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.VarBinding
import dk.sdu.mmmi.mdsd.math.VariableUse
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.Program
import dk.sdu.mmmi.mdsd.math.Parenthesis
import dk.sdu.mmmi.mdsd.math.ExternalVar
import dk.sdu.mmmi.mdsd.math.External
import org.eclipse.emf.common.util.EList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {
	
	static Map<String, Integer> variables;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) 
	{
		for (e : resource.allContents.toIterable.filter(Program)){
			fsa.generateFile(
			"math_expression/" + e.name + ".java",
			e.compile)
		}
		//val math = resource.allContents.filter(MathExp).next
		//val result = math.compute
		//result.displayPanel
		
	}
	
	/*def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}*/
	def static compile(Program p)
	{
		val program = p.name
		'''
		package math_expression;
		import java.util.*;
		
		public class «program» {
			
		«getAttr(p)»
		
		public «program»(«IF p.ext.size != 0»External external«ENDIF») 
		{
			«IF p.ext.size != 0»this.external = external;«ENDIF»
		}
		
		«getComputeCharSequence(p.math)»
		«getExternalInterface(p.ext)»
		}
		'''
	}
	def static getAttr(Program p)
	{
		val maths = p.math
		
		return '''
			«FOR m:maths.variables»
			public int «m.name»;
			«ENDFOR»
			
			«IF p.ext.size != 0»private External external;«ENDIF»
		'''
	}
	def static getExternalInterface(EList<External> externals) {
		var charCounter = 97
		return '''
		
			public interface External
			{
				«FOR external :externals»
					public int «external.name»(«FOR params :external.parameters SEPARATOR ',' »«params» «Character.toChars(charCounter++).toString().substring(1,2)»«ENDFOR»);
				«ENDFOR»
			}
			
		'''
	}
	
	def static getComputeCharSequence(MathExp math) {
		variables = new HashMap()
		return '''
		
			public void compute()
			{
				«FOR varBinding:math.variables»
					«varBinding.name» = «varBinding.computeExpressionG()»;
				«ENDFOR»
			}
			
		'''
	}
	
	def static dispatch CharSequence computeExpressionG(VarBinding binding) {
		//variables.put(binding.name, binding.expression.computeExpressionG())
		System.out.println("here " + binding.name)
		binding.expression.computeExpressionG 
	}
	def static dispatch CharSequence computeExpressionG(Parenthesis exp) {
		'''(«exp.exp.computeExpressionG»)'''
	}
	
	def static dispatch CharSequence computeExpressionG(MathNumber exp) {
		System.out.println(exp.value)
		'''«exp.value»'''
	}

	def static dispatch CharSequence computeExpressionG(Plus exp) {
		'''«exp.left.computeExpressionG» + «exp.right.computeExpressionG»'''
	}
	
	def static dispatch CharSequence computeExpressionG(Minus exp) {
		'''«exp.left.computeExpressionG» - «exp.right.computeExpressionG»'''
	}
	
	def static dispatch CharSequence computeExpressionG(Mult exp) {
		'''«exp.left.computeExpressionG» * «exp.right.computeExpressionG»'''
	
	}
	
	def static dispatch CharSequence computeExpressionG(Div exp) {
			'''«exp.left.computeExpressionG» / «exp.right.computeExpressionG»'''
	}

	def static dispatch CharSequence computeExpressionG(LetBinding exp) {
		exp.body.computeExpressionG
	}
	def static dispatch CharSequence computeExpressionG(ExternalVar exp) 
	{
		return '''
		this.external.«exp.ref.name»(«FOR expression:exp.param  SEPARATOR ',' »«expression.computeExpressionG»«ENDFOR»)
		'''
	}
	
	def static dispatch CharSequence computeExpressionG(VariableUse exp) {
		exp.ref.computeBindingG
	}

	def static dispatch CharSequence computeBindingG(VarBinding binding){
		if(!variables.containsKey(binding.name))
			binding.computeExpressionG()
		
		'''«binding.name»'''
	}
	
	def static dispatch CharSequence computeBindingG(LetBinding binding){
		'''(«binding.binding.computeExpressionG»)'''
	}
	/*
	def static compute(MathExp math) {
	variables = new HashMap()
	for(varBinding: math.variables)
		varBinding.computeExpression()
	variables
	}
	def static dispatch int computeExpression(VarBinding binding) {
		variables.put(binding.name, binding.expression.computeExpression())
		return variables.get(binding.name)
	}
	def static dispatch int computeExpression(Parenthesis exp) {
		exp.exp.computeExpression
	}
	def static dispatch int computeExpression(ExternalVar exp) 
	{
		System.out.println(exp.ref.name)
		return 0
	}
	
	def static dispatch int computeExpression(MathNumber exp) {
		exp.value
	}

	def static dispatch int computeExpression(Plus exp) {
		exp.left.computeExpression + exp.right.computeExpression
	}
	
	def static dispatch int computeExpression(Minus exp) {
		exp.left.computeExpression - exp.right.computeExpression
	}
	
	def static dispatch int computeExpression(Mult exp) {
		exp.left.computeExpression * exp.right.computeExpression
	}
	
	def static dispatch int computeExpression(Div exp) {
		exp.left.computeExpression / exp.right.computeExpression
	}

	def static dispatch int computeExpression(LetBinding exp) {
		exp.body.computeExpression
	}
	
	def static dispatch int computeExpression(VariableUse exp) {
		exp.ref.computeBinding
	}

	def static dispatch int computeBinding(VarBinding binding){
		if(!variables.containsKey(binding.name))
			binding.computeExpression()			
		variables.get(binding.name)
	}
	
	def static dispatch int computeBinding(LetBinding binding){
		binding.binding.computeExpression
	}
	*/
}
