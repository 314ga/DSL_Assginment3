/**
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator;

import com.google.common.collect.Iterables;
import dk.sdu.mmmi.mdsd.math.Binding;
import dk.sdu.mmmi.mdsd.math.Div;
import dk.sdu.mmmi.mdsd.math.Expression;
import dk.sdu.mmmi.mdsd.math.External;
import dk.sdu.mmmi.mdsd.math.ExternalVar;
import dk.sdu.mmmi.mdsd.math.LetBinding;
import dk.sdu.mmmi.mdsd.math.MathExp;
import dk.sdu.mmmi.mdsd.math.MathNumber;
import dk.sdu.mmmi.mdsd.math.Minus;
import dk.sdu.mmmi.mdsd.math.Mult;
import dk.sdu.mmmi.mdsd.math.Parenthesis;
import dk.sdu.mmmi.mdsd.math.Plus;
import dk.sdu.mmmi.mdsd.math.Program;
import dk.sdu.mmmi.mdsd.math.VarBinding;
import dk.sdu.mmmi.mdsd.math.VariableUse;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class MathGenerator extends AbstractGenerator {
  private static Map<String, Integer> variables;
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    Iterable<Program> _filter = Iterables.<Program>filter(IteratorExtensions.<EObject>toIterable(resource.getAllContents()), Program.class);
    for (final Program e : _filter) {
      String _name = e.getName();
      String _plus = ("math_expression/" + _name);
      String _plus_1 = (_plus + ".java");
      fsa.generateFile(_plus_1, 
        MathGenerator.compile(e));
    }
  }
  
  /**
   * def void displayPanel(Map<String, Integer> result) {
   * var resultString = ""
   * for (entry : result.entrySet()) {
   * resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
   * }
   * 
   * JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
   * }
   */
  public static CharSequence compile(final Program p) {
    CharSequence _xblockexpression = null;
    {
      final String program = p.getName();
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("package math_expression;");
      _builder.newLine();
      _builder.append("import java.util.*;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("public class ");
      _builder.append(program);
      _builder.append(" {");
      _builder.newLineIfNotEmpty();
      _builder.append("\t");
      _builder.newLine();
      String _attr = MathGenerator.getAttr(p);
      _builder.append(_attr);
      _builder.newLineIfNotEmpty();
      _builder.newLine();
      _builder.append("public ");
      _builder.append(program);
      _builder.append("(");
      {
        int _size = p.getExt().size();
        boolean _notEquals = (_size != 0);
        if (_notEquals) {
          _builder.append("External external");
        }
      }
      _builder.append(") ");
      _builder.newLineIfNotEmpty();
      _builder.append("{");
      _builder.newLine();
      _builder.append("\t");
      {
        int _size_1 = p.getExt().size();
        boolean _notEquals_1 = (_size_1 != 0);
        if (_notEquals_1) {
          _builder.append("this.external = external;");
        }
      }
      _builder.newLineIfNotEmpty();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      String _computeCharSequence = MathGenerator.getComputeCharSequence(p.getMath());
      _builder.append(_computeCharSequence);
      _builder.newLineIfNotEmpty();
      String _externalInterface = MathGenerator.getExternalInterface(p.getExt());
      _builder.append(_externalInterface);
      _builder.newLineIfNotEmpty();
      _builder.append("}");
      _builder.newLine();
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  public static String getAttr(final Program p) {
    final MathExp maths = p.getMath();
    StringConcatenation _builder = new StringConcatenation();
    {
      EList<VarBinding> _variables = maths.getVariables();
      for(final VarBinding m : _variables) {
        _builder.append("public int ");
        String _name = m.getName();
        _builder.append(_name);
        _builder.append(";");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    {
      int _size = p.getExt().size();
      boolean _notEquals = (_size != 0);
      if (_notEquals) {
        _builder.append("private External external;");
      }
    }
    _builder.newLineIfNotEmpty();
    return _builder.toString();
  }
  
  public static String getExternalInterface(final EList<External> externals) {
    int charCounter = 97;
    StringConcatenation _builder = new StringConcatenation();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public interface External");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("{");
    _builder.newLine();
    {
      for(final External external : externals) {
        _builder.append("\t\t");
        _builder.append("public int ");
        String _name = external.getName();
        _builder.append(_name, "\t\t");
        _builder.append("(");
        {
          EList<String> _parameters = external.getParameters();
          boolean _hasElements = false;
          for(final String params : _parameters) {
            if (!_hasElements) {
              _hasElements = true;
            } else {
              _builder.appendImmediate(",", "\t\t");
            }
            _builder.append(params, "\t\t");
            _builder.append(" ");
            int _plusPlus = charCounter++;
            String _substring = ((List<Character>)Conversions.doWrapArray(Character.toChars(_plusPlus))).toString().substring(1, 2);
            _builder.append(_substring, "\t\t");
          }
        }
        _builder.append(");");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    return _builder.toString();
  }
  
  public static String getComputeCharSequence(final MathExp math) {
    HashMap<String, Integer> _hashMap = new HashMap<String, Integer>();
    MathGenerator.variables = _hashMap;
    StringConcatenation _builder = new StringConcatenation();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public void compute()");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("{");
    _builder.newLine();
    {
      EList<VarBinding> _variables = math.getVariables();
      for(final VarBinding varBinding : _variables) {
        _builder.append("\t\t");
        String _name = varBinding.getName();
        _builder.append(_name, "\t\t");
        _builder.append(" = ");
        CharSequence _computeExpressionG = MathGenerator.computeExpressionG(varBinding);
        _builder.append(_computeExpressionG, "\t\t");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    return _builder.toString();
  }
  
  protected static CharSequence _computeExpressionG(final VarBinding binding) {
    CharSequence _xblockexpression = null;
    {
      String _name = binding.getName();
      String _plus = ("here " + _name);
      System.out.println(_plus);
      _xblockexpression = MathGenerator.computeExpressionG(binding.getExpression());
    }
    return _xblockexpression;
  }
  
  protected static CharSequence _computeExpressionG(final Parenthesis exp) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(");
    CharSequence _computeExpressionG = MathGenerator.computeExpressionG(exp.getExp());
    _builder.append(_computeExpressionG);
    _builder.append(")");
    return _builder;
  }
  
  protected static CharSequence _computeExpressionG(final MathNumber exp) {
    CharSequence _xblockexpression = null;
    {
      System.out.println(exp.getValue());
      StringConcatenation _builder = new StringConcatenation();
      int _value = exp.getValue();
      _builder.append(_value);
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  protected static CharSequence _computeExpressionG(final Plus exp) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _computeExpressionG = MathGenerator.computeExpressionG(exp.getLeft());
    _builder.append(_computeExpressionG);
    _builder.append(" + ");
    CharSequence _computeExpressionG_1 = MathGenerator.computeExpressionG(exp.getRight());
    _builder.append(_computeExpressionG_1);
    return _builder;
  }
  
  protected static CharSequence _computeExpressionG(final Minus exp) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _computeExpressionG = MathGenerator.computeExpressionG(exp.getLeft());
    _builder.append(_computeExpressionG);
    _builder.append(" - ");
    CharSequence _computeExpressionG_1 = MathGenerator.computeExpressionG(exp.getRight());
    _builder.append(_computeExpressionG_1);
    return _builder;
  }
  
  protected static CharSequence _computeExpressionG(final Mult exp) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _computeExpressionG = MathGenerator.computeExpressionG(exp.getLeft());
    _builder.append(_computeExpressionG);
    _builder.append(" * ");
    CharSequence _computeExpressionG_1 = MathGenerator.computeExpressionG(exp.getRight());
    _builder.append(_computeExpressionG_1);
    return _builder;
  }
  
  protected static CharSequence _computeExpressionG(final Div exp) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _computeExpressionG = MathGenerator.computeExpressionG(exp.getLeft());
    _builder.append(_computeExpressionG);
    _builder.append(" / ");
    CharSequence _computeExpressionG_1 = MathGenerator.computeExpressionG(exp.getRight());
    _builder.append(_computeExpressionG_1);
    return _builder;
  }
  
  protected static CharSequence _computeExpressionG(final LetBinding exp) {
    return MathGenerator.computeExpressionG(exp.getBody());
  }
  
  protected static CharSequence _computeExpressionG(final ExternalVar exp) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("this.external.");
    String _name = exp.getRef().getName();
    _builder.append(_name);
    _builder.append("(");
    {
      EList<Expression> _param = exp.getParam();
      boolean _hasElements = false;
      for(final Expression expression : _param) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(",", "");
        }
        CharSequence _computeExpressionG = MathGenerator.computeExpressionG(expression);
        _builder.append(_computeExpressionG);
      }
    }
    _builder.append(")");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  protected static CharSequence _computeExpressionG(final VariableUse exp) {
    return MathGenerator.computeBindingG(exp.getRef());
  }
  
  protected static CharSequence _computeBindingG(final VarBinding binding) {
    CharSequence _xblockexpression = null;
    {
      boolean _containsKey = MathGenerator.variables.containsKey(binding.getName());
      boolean _not = (!_containsKey);
      if (_not) {
        MathGenerator.computeExpressionG(binding);
      }
      StringConcatenation _builder = new StringConcatenation();
      String _name = binding.getName();
      _builder.append(_name);
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  protected static CharSequence _computeBindingG(final LetBinding binding) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(");
    CharSequence _computeExpressionG = MathGenerator.computeExpressionG(binding.getBinding());
    _builder.append(_computeExpressionG);
    _builder.append(")");
    return _builder;
  }
  
  public static CharSequence computeExpressionG(final EObject exp) {
    if (exp instanceof Div) {
      return _computeExpressionG((Div)exp);
    } else if (exp instanceof ExternalVar) {
      return _computeExpressionG((ExternalVar)exp);
    } else if (exp instanceof LetBinding) {
      return _computeExpressionG((LetBinding)exp);
    } else if (exp instanceof MathNumber) {
      return _computeExpressionG((MathNumber)exp);
    } else if (exp instanceof Minus) {
      return _computeExpressionG((Minus)exp);
    } else if (exp instanceof Mult) {
      return _computeExpressionG((Mult)exp);
    } else if (exp instanceof Parenthesis) {
      return _computeExpressionG((Parenthesis)exp);
    } else if (exp instanceof Plus) {
      return _computeExpressionG((Plus)exp);
    } else if (exp instanceof VarBinding) {
      return _computeExpressionG((VarBinding)exp);
    } else if (exp instanceof VariableUse) {
      return _computeExpressionG((VariableUse)exp);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(exp).toString());
    }
  }
  
  public static CharSequence computeBindingG(final Binding binding) {
    if (binding instanceof LetBinding) {
      return _computeBindingG((LetBinding)binding);
    } else if (binding instanceof VarBinding) {
      return _computeBindingG((VarBinding)binding);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(binding).toString());
    }
  }
}
